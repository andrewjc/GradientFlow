# -*- coding: utf-8 -*-
"""
HTML Report Generation
======================

Generates beautiful, interactive HTML reports for gradient flow analysis.
Includes visualizations, charts, and detailed diagnostics.
"""

from typing import Dict, Any, List
import json


class HTMLReportGenerator:
    """
    Generates interactive HTML reports for gradient flow analysis.

    The generated HTML includes:
    - Summary dashboard with key metrics
    - Interactive layer table with sorting/filtering
    - Gradient flow visualizations
    - Issue highlighting and recommendations
    - Export functionality
    """

    def __init__(self, theme: str = "dark"):
        """
        Initialize HTML generator.

        Args:
            theme: Color theme ("dark" or "light")
        """
        self.theme = theme

    def generate(self, report) -> str:
        """
        Generate complete HTML report.

        Args:
            report: FlowReport object

        Returns:
            Complete HTML document as string
        """
        summary = report.summary
        metrics_json = json.dumps({
            name: m.to_dict() for name, m in report.metrics.items()
        })
        health_json = json.dumps({
            name: h.to_dict() for name, h in report.health.items()
        })
        issues_json = json.dumps(report.issues)

        html = f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Flow Analysis - {report.model_name}</title>
    <style>
        {self._get_styles()}
    </style>
</head>
<body class="{self.theme}">
    <header>
        <div class="container">
            <h1>üåä Gradient Hydrodynamics Report</h1>
            <h2>{report.model_name}</h2>
        </div>
    </header>

    <main class="container">
        {self._generate_summary_section(summary)}
        {self._generate_health_gauge(summary)}
        {self._generate_issues_section(report.issues)}
        {self._generate_layer_table(report)}
        {self._generate_recommendations_section(report)}
        {self._generate_methodology_section()}
    </main>

    <footer>
        <div class="container">
            <p>Generated by <strong>Gradient Hydrodynamics Toolkit</strong></p>
            <p>Learn more at <a href="https://gradient-flow.dev">gradient-flow.dev</a></p>
        </div>
    </footer>

    <script>
        const metrics = {metrics_json};
        const health = {health_json};
        const issues = {issues_json};

        {self._get_scripts()}
    </script>
</body>
</html>'''
        return html

    def _get_styles(self) -> str:
        """Get CSS styles."""
        return '''
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-card: #0f3460;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --accent: #e94560;
            --success: #00d26a;
            --warning: #ffc107;
            --danger: #ff4757;
            --info: #3498db;
        }

        .light {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-card: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-card));
            padding: 40px 0;
            border-bottom: 3px solid var(--accent);
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        header h2 {
            color: var(--text-secondary);
            font-weight: normal;
        }

        main {
            padding: 40px 0;
        }

        .section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .section h3 {
            color: var(--accent);
            margin-bottom: 20px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .stat-card.success .stat-value { color: var(--success); }
        .stat-card.warning .stat-value { color: var(--warning); }
        .stat-card.danger .stat-value { color: var(--danger); }

        .health-gauge {
            width: 200px;
            height: 200px;
            margin: 20px auto;
            position: relative;
        }

        .gauge-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                var(--success) 0deg calc(var(--health) * 3.6deg),
                var(--bg-card) calc(var(--health) * 3.6deg) 360deg
            );
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .gauge-inner {
            width: 150px;
            height: 150px;
            background: var(--bg-secondary);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .gauge-value {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .gauge-label {
            color: var(--text-secondary);
        }

        .issue-list {
            list-style: none;
        }

        .issue-item {
            background: var(--bg-card);
            border-left: 4px solid var(--danger);
            padding: 15px 20px;
            margin-bottom: 10px;
            border-radius: 0 8px 8px 0;
            display: grid;
            grid-template-columns: 100px 80px 1fr;
            gap: 20px;
            align-items: center;
        }

        .issue-item.high { border-color: var(--warning); }
        .issue-item.medium { border-color: var(--info); }

        .issue-type {
            font-weight: bold;
            text-transform: uppercase;
        }

        .issue-severity {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            text-align: center;
        }

        .issue-severity.critical { background: var(--danger); }
        .issue-severity.high { background: var(--warning); color: #000; }
        .issue-severity.medium { background: var(--info); }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--bg-card);
        }

        th {
            background: var(--bg-card);
            font-weight: 600;
            cursor: pointer;
        }

        th:hover {
            background: var(--accent);
        }

        tr:hover {
            background: var(--bg-card);
        }

        .health-bar {
            width: 100px;
            height: 8px;
            background: var(--bg-card);
            border-radius: 4px;
            overflow: hidden;
        }

        .health-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .recommendations-list {
            list-style: decimal;
            padding-left: 20px;
        }

        .recommendations-list li {
            padding: 10px 0;
            border-bottom: 1px solid var(--bg-card);
        }

        .methodology {
            background: var(--bg-card);
            padding: 20px;
            border-radius: 8px;
            font-family: monospace;
        }

        footer {
            background: var(--bg-secondary);
            padding: 30px 0;
            text-align: center;
            border-top: 1px solid var(--bg-card);
        }

        footer a {
            color: var(--accent);
        }

        @media (max-width: 768px) {
            .issue-item {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }
        '''

    def _generate_summary_section(self, summary: Dict[str, Any]) -> str:
        """Generate summary statistics section."""
        status_class = "success" if summary["status"] == "HEALTHY" else (
            "warning" if summary["status"] in ["WARNING", "ATTENTION"] else "danger"
        )

        return f'''
        <section class="section">
            <h3>üìä Analysis Summary</h3>
            <div class="summary-grid">
                <div class="stat-card">
                    <div class="stat-value">{summary["total_layers"]}</div>
                    <div class="stat-label">Layers Analyzed</div>
                </div>
                <div class="stat-card {'success' if summary['avg_health'] >= 75 else 'warning' if summary['avg_health'] >= 50 else 'danger'}">
                    <div class="stat-value">{summary["avg_health"]:.1f}%</div>
                    <div class="stat-label">Average Health</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">{summary["healthy_layers"]}/{summary["total_layers"]}</div>
                    <div class="stat-label">Healthy Layers</div>
                </div>
                <div class="stat-card {'danger' if summary['critical_issues'] > 0 else 'success'}">
                    <div class="stat-value">{summary["total_issues"]}</div>
                    <div class="stat-label">Issues Found</div>
                </div>
                <div class="stat-card {status_class}">
                    <div class="stat-value">{summary["status"]}</div>
                    <div class="stat-label">Overall Status</div>
                </div>
            </div>
        </section>
        '''

    def _generate_health_gauge(self, summary: Dict[str, Any]) -> str:
        """Generate health gauge visualization."""
        health = summary["avg_health"]
        color = "#00d26a" if health >= 75 else "#ffc107" if health >= 50 else "#ff4757"

        return f'''
        <section class="section" style="text-align: center;">
            <h3>üíö Overall Model Health</h3>
            <div class="health-gauge">
                <div class="gauge-circle" style="--health: {health};">
                    <div class="gauge-inner">
                        <div class="gauge-value" style="color: {color};">{health:.0f}%</div>
                        <div class="gauge-label">Health Score</div>
                    </div>
                </div>
            </div>
        </section>
        '''

    def _generate_issues_section(self, issues: List[Dict[str, Any]]) -> str:
        """Generate issues section."""
        if not issues:
            return '''
            <section class="section">
                <h3>‚úÖ No Issues Detected</h3>
                <p>Your model's gradient flow looks healthy! No pathological patterns were found.</p>
            </section>
            '''

        issues_html = ""
        for issue in sorted(issues, key=lambda x: (
            0 if x["severity"] == "CRITICAL" else
            1 if x["severity"] == "HIGH" else 2
        )):
            severity_class = issue["severity"].lower()
            issues_html += f'''
            <li class="issue-item {severity_class}">
                <span class="issue-type">{issue["type"]}</span>
                <span class="issue-severity {severity_class}">{issue["severity"]}</span>
                <span><strong>{issue["layer"]}</strong>: {issue["info"]}</span>
            </li>
            '''

        return f'''
        <section class="section">
            <h3>‚ö†Ô∏è Issues Detected ({len(issues)})</h3>
            <ul class="issue-list">
                {issues_html}
            </ul>
        </section>
        '''

    def _generate_layer_table(self, report) -> str:
        """Generate layer-by-layer table."""
        rows = ""
        for name, health in sorted(report.health.items(), key=lambda x: x[1].score):
            metrics = report.metrics.get(name)
            if metrics:
                color = "#00d26a" if health.score >= 75 else "#ffc107" if health.score >= 50 else "#ff4757"
                rows += f'''
                <tr>
                    <td>{name}</td>
                    <td>{health.layer_type}</td>
                    <td>{metrics.mean_pressure:.2e}</td>
                    <td>{metrics.max_pressure:.2e}</td>
                    <td>{metrics.turbulence:.2e}</td>
                    <td>
                        <div class="health-bar">
                            <div class="health-bar-fill" style="width: {health.score}%; background: {color};"></div>
                        </div>
                        {health.score:.1f}%
                    </td>
                </tr>
                '''

        return f'''
        <section class="section">
            <h3>üìã Layer-by-Layer Analysis</h3>
            <table id="layerTable">
                <thead>
                    <tr>
                        <th onclick="sortTable(0)">Layer</th>
                        <th onclick="sortTable(1)">Type</th>
                        <th onclick="sortTable(2)">Mean Pressure</th>
                        <th onclick="sortTable(3)">Max Pressure</th>
                        <th onclick="sortTable(4)">Turbulence</th>
                        <th onclick="sortTable(5)">Health</th>
                    </tr>
                </thead>
                <tbody>
                    {rows}
                </tbody>
            </table>
        </section>
        '''

    def _generate_recommendations_section(self, report) -> str:
        """Generate recommendations section."""
        all_recs = set()
        for h in report.health.values():
            all_recs.update(h.recommendations)

        if not all_recs:
            return ""

        recs_html = "".join(f"<li>{rec}</li>" for rec in sorted(all_recs))

        return f'''
        <section class="section">
            <h3>üí° Recommendations</h3>
            <ol class="recommendations-list">
                {recs_html}
            </ol>
        </section>
        '''

    def _generate_methodology_section(self) -> str:
        """Generate methodology explanation section."""
        return '''
        <section class="section">
            <h3>üî¨ Methodology</h3>
            <div class="methodology">
                <p><strong>Gradient Hydrodynamics</strong> treats neural network gradient flow as a fluid dynamics problem:</p>
                <ul style="margin: 15px 0; padding-left: 20px;">
                    <li><strong>Pressure</strong> = Gradient L2 norm (how much "force" is flowing)</li>
                    <li><strong>Turbulence</strong> = Gradient variance (flow stability)</li>
                    <li><strong>Velocity</strong> = Rate of change in gradients</li>
                    <li><strong>Blockages</strong> = Vanishing gradients (clogged pipes)</li>
                    <li><strong>Bursts</strong> = Exploding gradients (over-pressurized pipes)</li>
                </ul>
                <p>This metaphor enables intuitive diagnosis of training pathologies.</p>
            </div>
        </section>
        '''

    def _get_scripts(self) -> str:
        """Get JavaScript for interactivity."""
        return '''
        function sortTable(n) {
            const table = document.getElementById("layerTable");
            let rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
            switching = true;
            dir = "asc";
            while (switching) {
                switching = false;
                rows = table.rows;
                for (i = 1; i < (rows.length - 1); i++) {
                    shouldSwitch = false;
                    x = rows[i].getElementsByTagName("TD")[n];
                    y = rows[i + 1].getElementsByTagName("TD")[n];
                    let xVal = x.innerText.toLowerCase();
                    let yVal = y.innerText.toLowerCase();
                    // Try to parse as number
                    if (!isNaN(parseFloat(xVal))) {
                        xVal = parseFloat(xVal);
                        yVal = parseFloat(yVal);
                    }
                    if (dir == "asc") {
                        if (xVal > yVal) {
                            shouldSwitch = true;
                            break;
                        }
                    } else if (dir == "desc") {
                        if (xVal < yVal) {
                            shouldSwitch = true;
                            break;
                        }
                    }
                }
                if (shouldSwitch) {
                    rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                    switching = true;
                    switchcount++;
                } else {
                    if (switchcount == 0 && dir == "asc") {
                        dir = "desc";
                        switching = true;
                    }
                }
            }
        }
        '''
